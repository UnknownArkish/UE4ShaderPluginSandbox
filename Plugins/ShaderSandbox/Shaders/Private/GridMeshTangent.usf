#include "/Engine/Public/Platform.ush"

uint NumRow;
uint NumColumn;
uint NumVertex;
RWBuffer<float> InPositionVertexBuffer;
RWBuffer<float4> OutTangentVertexBuffer;

float4 PackNormal(float3 V)
{
	return float4(clamp(V,float(-1).xxx,float(1).xxx), 1.0f);
}

[numthreads(32, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const uint VertexIndex = DispatchThreadId.x;

	if (VertexIndex >= NumVertex)
	{
		return;
	}

	// NumVertex == (NumRow + 1) * (NumColumn + 1)

	uint RowIndex = VertexIndex / (NumColumn + 1);
	uint ColumnIndex = VertexIndex % (NumColumn + 1);

    float3 CurrVertexPos;
    CurrVertexPos.x = InPositionVertexBuffer[3 * VertexIndex];
    CurrVertexPos.y = InPositionVertexBuffer[3 * VertexIndex + 1];
    CurrVertexPos.z = InPositionVertexBuffer[3 * VertexIndex + 2];

	float3 ZAxis = float3(0.0, 0.0, 1.0);

    float3 SumOfEachEdgeNormal = float3(0.0, 0.0, 0.0);
    float3 DebugEdgeNormal = float3(0.0, 0.0, 0.0);

	if (RowIndex < NumRow)
    {
        uint RightVertexIndex = VertexIndex + 1;
        float3 RightVertexPos;
		RightVertexPos.x = InPositionVertexBuffer[3 * RightVertexIndex];
		RightVertexPos.y = InPositionVertexBuffer[3 * RightVertexIndex + 1];
		RightVertexPos.z = InPositionVertexBuffer[3 * RightVertexIndex + 2];

        float3 RightEdgeAxis = normalize(RightVertexPos - CurrVertexPos);
		// RightEdgeNormal should not bet zero vector at no zero tile width grid mesh. So it can be normalized.
        float3 RightEdgeNormal = normalize(ZAxis - dot(ZAxis, RightEdgeAxis) * RightEdgeAxis);

        SumOfEachEdgeNormal += RightEdgeNormal;
    }

	if (ColumnIndex < NumColumn)
    {
        uint LowerVertexIndex = VertexIndex + NumColumn + 1;
        float3 LowerVertexPos;
		LowerVertexPos.x = InPositionVertexBuffer[3 * LowerVertexIndex];
		LowerVertexPos.y = InPositionVertexBuffer[3 * LowerVertexIndex + 1];
		LowerVertexPos.z = InPositionVertexBuffer[3 * LowerVertexIndex + 2];

        float3 LowerEdgeAxis = normalize(LowerVertexPos - CurrVertexPos);
		// LowerEdgeNormal should not bet zero vector at no zero tile width grid mesh. So it can be normalized.
        float3 LowerEdgeNormal = normalize(ZAxis - dot(ZAxis, LowerEdgeAxis) * LowerEdgeAxis);

        SumOfEachEdgeNormal += LowerEdgeNormal;
    }

	if (RowIndex > 0)
    {
        uint LeftVertexIndex = VertexIndex - 1;
        float3 LeftVertexPos;
		LeftVertexPos.x = InPositionVertexBuffer[3 * LeftVertexIndex];
		LeftVertexPos.y = InPositionVertexBuffer[3 * LeftVertexIndex + 1];
		LeftVertexPos.z = InPositionVertexBuffer[3 * LeftVertexIndex + 2];

        float3 LeftEdgeAxis = normalize(LeftVertexPos - CurrVertexPos);
		// LeftEdgeNormal should not bet zero vector at no zero tile width grid mesh. So it can be normalized.
        float3 LeftEdgeNormal = normalize(ZAxis - dot(ZAxis, LeftEdgeAxis) * LeftEdgeAxis);

        SumOfEachEdgeNormal += LeftEdgeNormal;
    }

	if (ColumnIndex > 0)
    {
        uint UpperVertexIndex = VertexIndex - NumColumn - 1;
        float3 UpperVertexPos;
		UpperVertexPos.x = InPositionVertexBuffer[3 * UpperVertexIndex];
		UpperVertexPos.y = InPositionVertexBuffer[3 * UpperVertexIndex + 1];
		UpperVertexPos.z = InPositionVertexBuffer[3 * UpperVertexIndex + 2];

        float3 UpperEdgeAxis = normalize(UpperVertexPos - CurrVertexPos);
		// UpperEdgeNormal should not bet zero vector at no zero tile width grid mesh. So it can be normalized.
        float3 UpperEdgeNormal = normalize(ZAxis - dot(ZAxis, UpperEdgeAxis) * UpperEdgeAxis);

        SumOfEachEdgeNormal += UpperEdgeNormal;
    }

	// TagentZ cannot be zero at the grid mesh which have one tile at least.
    float3 TangentZ = normalize(SumOfEachEdgeNormal);

    float3 XAxis = float3(1.0, 0.0, 0.0);
	// NewTangent should not bet zero vector at no zero tile width grid mesh. So it can be normalized.
    float3 TangentX = normalize(XAxis - dot(XAxis, TangentZ) * TangentZ);

	OutTangentVertexBuffer[VertexIndex * 2] = PackNormal(TangentX);
    OutTangentVertexBuffer[VertexIndex * 2 + 1] = PackNormal(TangentZ);
    //OutTangentVertexBuffer[VertexIndex * 2 + 1] = PackNormal(DebugEdgeNormal);
	return;
}
