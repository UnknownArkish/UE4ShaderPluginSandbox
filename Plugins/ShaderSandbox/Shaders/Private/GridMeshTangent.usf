#include "/Engine/Public/Platform.ush"

uint NumRow;
uint NumColumn;
uint NumVertex;
RWBuffer<float> InPositionVertexBuffer;
RWBuffer<float4> OutTangentVertexBuffer;

float4 PackNormal(float3 V)
{
	return float4(clamp(V,float(-1).xxx,float(1).xxx), 1.0f);
}

[numthreads(32, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const float SMALL_NUMBER = 0.0001;
	const uint VertexIndex = DispatchThreadId.x;

	if (VertexIndex >= NumVertex)
	{
		return;
	}

	// NumVertex == (NumRow + 1) * (NumColumn + 1)

	uint RowIndex = VertexIndex / (NumColumn + 1);
	uint ColumnIndex = VertexIndex % (NumColumn + 1);

    float3 CurrVertexPos;
    CurrVertexPos.x = InPositionVertexBuffer[4 * VertexIndex];
    CurrVertexPos.y = InPositionVertexBuffer[4 * VertexIndex + 1];
    CurrVertexPos.z = InPositionVertexBuffer[4 * VertexIndex + 2];

	float3 ZAxis = float3(0.0, 0.0, 1.0);
	float3 YAxis = float3(0.0, 0.0, 1.0);

    float3 SumOfEachEdgeNormal = float3(0.0, 0.0, 0.0);
    float3 DebugEdgeNormal = float3(0.0, 0.0, 0.0);

	if (ColumnIndex < NumColumn)
    {
        uint RightVertexIndex = VertexIndex + 1;
        float3 RightVertexPos;
		RightVertexPos.x = InPositionVertexBuffer[4 * RightVertexIndex];
		RightVertexPos.y = InPositionVertexBuffer[4 * RightVertexIndex + 1];
		RightVertexPos.z = InPositionVertexBuffer[4 * RightVertexIndex + 2];

		float RightEdgeLength = max(length(RightVertexPos - CurrVertexPos), SMALL_NUMBER); // to avoid 0 division
        float3 RightEdgeAxis = (RightVertexPos - CurrVertexPos) / RightEdgeLength;

		float3 RightEdgeNormal;

		float ProjectionToZAxis = dot(ZAxis, RightEdgeAxis);
		if (ProjectionToZAxis < SMALL_NUMBER)
		{
			// ほぼエッジ方向がZ軸方向のときはnomalize()に0ベクトルを入れないようにノーマルをY軸とする
			RightEdgeNormal = YAxis;
		}
		else
		{
			RightEdgeNormal = normalize(ZAxis - dot(ZAxis, RightEdgeAxis) * RightEdgeAxis);
		}

        SumOfEachEdgeNormal += RightEdgeNormal;
    }

	if (RowIndex < NumRow)
    {
        uint LowerVertexIndex = VertexIndex + NumColumn + 1;
        float3 LowerVertexPos;
		LowerVertexPos.x = InPositionVertexBuffer[4 * LowerVertexIndex];
		LowerVertexPos.y = InPositionVertexBuffer[4 * LowerVertexIndex + 1];
		LowerVertexPos.z = InPositionVertexBuffer[4 * LowerVertexIndex + 2];

		float LowerEdgeLength = max(length(LowerVertexPos - CurrVertexPos), SMALL_NUMBER); // to avoid 0 division
        float3 LowerEdgeAxis = (LowerVertexPos - CurrVertexPos) / LowerEdgeLength;

		float3 LowerEdgeNormal;

		float ProjectionToZAxis = dot(ZAxis, LowerEdgeAxis);
		if (ProjectionToZAxis > 1.0 - SMALL_NUMBER)
		{
			// ほぼエッジ方向がZ軸方向のときはnomalize()に0ベクトルを入れないようにノーマルをY軸とする
			LowerEdgeNormal = YAxis;
		}
		else
		{
			LowerEdgeNormal = normalize(ZAxis - dot(ZAxis, LowerEdgeAxis) * LowerEdgeAxis);
		}

        SumOfEachEdgeNormal += LowerEdgeNormal;
    }

	if (ColumnIndex > 0)
    {
        uint LeftVertexIndex = VertexIndex - 1;
        float3 LeftVertexPos;
		LeftVertexPos.x = InPositionVertexBuffer[4 * LeftVertexIndex];
		LeftVertexPos.y = InPositionVertexBuffer[4 * LeftVertexIndex + 1];
		LeftVertexPos.z = InPositionVertexBuffer[4 * LeftVertexIndex + 2];

		float LeftEdgeLength = max(length(LeftVertexPos - CurrVertexPos), SMALL_NUMBER); // to avoid 0 division
        float3 LeftEdgeAxis = (LeftVertexPos - CurrVertexPos) / LeftEdgeLength;

		float3 LeftEdgeNormal;

		float ProjectionToZAxis = dot(ZAxis, LeftEdgeAxis);
		if (ProjectionToZAxis < SMALL_NUMBER)
		{
			// ほぼエッジ方向がZ軸方向のときはnomalize()に0ベクトルを入れないようにノーマルをY軸とする
			LeftEdgeNormal = YAxis;
		}
		else
		{
			LeftEdgeNormal = normalize(ZAxis - dot(ZAxis, LeftEdgeAxis) * LeftEdgeAxis);
		}

        SumOfEachEdgeNormal += LeftEdgeNormal;
    }

	if (RowIndex > 0)
    {
        uint UpperVertexIndex = VertexIndex - NumColumn - 1;
        float3 UpperVertexPos;
		UpperVertexPos.x = InPositionVertexBuffer[4 * UpperVertexIndex];
		UpperVertexPos.y = InPositionVertexBuffer[4 * UpperVertexIndex + 1];
		UpperVertexPos.z = InPositionVertexBuffer[4 * UpperVertexIndex + 2];

		float UpperEdgeLength = max(length(UpperVertexPos - CurrVertexPos), SMALL_NUMBER); // to avoid 0 division
        float3 UpperEdgeAxis = (UpperVertexPos - CurrVertexPos) / UpperEdgeLength;

		float3 UpperEdgeNormal;

		float ProjectionToZAxis = dot(ZAxis, UpperEdgeAxis);
		if (ProjectionToZAxis < SMALL_NUMBER)
		{
			// ほぼエッジ方向がZ軸方向のときはnomalize()に0ベクトルを入れないようにノーマルをY軸とする
			UpperEdgeNormal = YAxis;
		}
		else
		{
			UpperEdgeNormal = normalize(ZAxis - dot(ZAxis, UpperEdgeAxis) * UpperEdgeAxis);
		}

        SumOfEachEdgeNormal += UpperEdgeNormal;
    }

	// TagentZ cannot be zero at the grid mesh which have one tile at least.
    float3 TangentZ = normalize(SumOfEachEdgeNormal);

    float3 XAxis = float3(1.0, 0.0, 0.0);
	// NewTangent should not bet zero vector at no zero tile width grid mesh. So it can be normalized.
    float3 TangentX = normalize(XAxis - dot(XAxis, TangentZ) * TangentZ);

	OutTangentVertexBuffer[VertexIndex * 2] = PackNormal(TangentX);
    OutTangentVertexBuffer[VertexIndex * 2 + 1] = PackNormal(TangentZ);
    //OutTangentVertexBuffer[VertexIndex * 2 + 1] = PackNormal(DebugEdgeNormal);
	return;
}
