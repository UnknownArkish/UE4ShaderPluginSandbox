#include "/Engine/Public/Platform.ush"

uint NumRow;
uint NumColumn;
uint NumVertex;
float GridWidth;
float GridHeight;
float SquareDeltaTime;

Buffer<float> InAccelerationVertexBuffer;
RWBuffer<float> OutPrevPositionVertexBuffer;
RWBuffer<float> OutPositionVertexBuffer;

[numthreads(32, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const float SMALL_NUMBER = 0.0001;
	const uint VertexIndex = DispatchThreadId.x;

	if (VertexIndex < NumVertex)
	{
		uint RowIndex = VertexIndex / (NumColumn + 1);
		uint ColumnIndex = VertexIndex % (NumColumn + 1);

		//
		// integrate
		//
		float3 CurrPos = float3(OutPositionVertexBuffer[4 * VertexIndex + 0], OutPositionVertexBuffer[4 * VertexIndex + 1], OutPositionVertexBuffer[4 * VertexIndex + 2]);
		float3 PrevPos = float3(OutPrevPositionVertexBuffer[4 * VertexIndex + 0], OutPrevPositionVertexBuffer[4 * VertexIndex + 1], OutPrevPositionVertexBuffer[4 * VertexIndex + 2]);

		float3 NextPos;

		// Ž¿—Ê‚Í•Ï‚í‚ç‚È‚¢‚Æ‚¢‚¤‘O’ñ‚ð’u‚¢‚Ä‚¢‚é
		float CurrInvMass = OutPositionVertexBuffer[4 * VertexIndex + 3];
		if (CurrInvMass < SMALL_NUMBER)
		{
			NextPos = CurrPos;
		}
		else
		{
			// ‚Æ‚è‚ ‚¦‚¸Damping‚Í0.1‚É‚µ‚Ä0.9‚ð‚©‚¯‚é
			float3 Acceleration = float3(InAccelerationVertexBuffer[3 * VertexIndex + 0], InAccelerationVertexBuffer[3 * VertexIndex + 1], InAccelerationVertexBuffer[3 * VertexIndex + 2]);
			NextPos = CurrPos + (CurrPos - PrevPos) * 0.9 + Acceleration * SquareDeltaTime;
		}

		OutPositionVertexBuffer[4 * VertexIndex + 0] = NextPos.x;
		OutPositionVertexBuffer[4 * VertexIndex + 1] = NextPos.y;
		OutPositionVertexBuffer[4 * VertexIndex + 2] = NextPos.z;

		OutPrevPositionVertexBuffer[4 * VertexIndex + 0] = CurrPos.x;
		OutPrevPositionVertexBuffer[4 * VertexIndex + 1] = CurrPos.y;
		OutPrevPositionVertexBuffer[4 * VertexIndex + 2] = CurrPos.z;

		//
		// edge rest length constraint
		//
	}
}

