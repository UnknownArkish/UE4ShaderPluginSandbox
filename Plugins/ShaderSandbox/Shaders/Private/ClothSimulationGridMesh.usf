#include "/Engine/Public/Platform.ush"

uint NumRow;
uint NumColumn;
uint NumVertex;
float GridWidth;
float GridHeight;
float SquareDeltaTime;
float Stiffness;
float Damping;
float3 SphereCenter;
float SphereRadius;

Buffer<float> InAccelerationVertexBuffer;
RWBuffer<float> OutPrevPositionVertexBuffer;
RWBuffer<float> OutPositionVertexBuffer;

[numthreads(1, 1, 1)]
void Interate(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const float SMALL_NUMBER = 0.0001;

	for (uint VertIdx = 0; VertIdx < NumVertex; VertIdx++)
	{
		float3 CurrPos = float3(OutPositionVertexBuffer[4 * VertIdx + 0], OutPositionVertexBuffer[4 * VertIdx + 1], OutPositionVertexBuffer[4 * VertIdx + 2]);
		float3 PrevPos = float3(OutPrevPositionVertexBuffer[4 * VertIdx + 0], OutPrevPositionVertexBuffer[4 * VertIdx + 1], OutPrevPositionVertexBuffer[4 * VertIdx + 2]);

		float3 NextPos;

		// 質量は変わらないという前提を置いている
		float CurrInvMass = OutPositionVertexBuffer[4 * VertIdx + 3];
		if (CurrInvMass < SMALL_NUMBER)
		{
			NextPos = CurrPos;
		}
		else
		{
			// とりあえずDampingは0.1にして0.9をかける
			float3 Acceleration = float3(InAccelerationVertexBuffer[3 * VertIdx + 0], InAccelerationVertexBuffer[3 * VertIdx + 1], InAccelerationVertexBuffer[3 * VertIdx + 2]);
			NextPos = CurrPos + (CurrPos - PrevPos) * (1.0 - Damping) + Acceleration * SquareDeltaTime;
		}

		OutPositionVertexBuffer[4 * VertIdx + 0] = NextPos.x;
		OutPositionVertexBuffer[4 * VertIdx + 1] = NextPos.y;
		OutPositionVertexBuffer[4 * VertIdx + 2] = NextPos.z;

		OutPrevPositionVertexBuffer[4 * VertIdx + 0] = CurrPos.x;
		OutPrevPositionVertexBuffer[4 * VertIdx + 1] = CurrPos.y;
		OutPrevPositionVertexBuffer[4 * VertIdx + 2] = CurrPos.z;
	}
}

[numthreads(1, 1, 1)]
void SolveDistanceConstraint(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const float SMALL_NUMBER = 0.0001;

	for (uint VertIdx = 0; VertIdx < NumVertex; VertIdx++)
	{
		uint RowIndex = VertIdx / (NumColumn + 1);
		uint ColumnIndex = VertIdx % (NumColumn + 1);

		float3 CurrVertexPos;
		CurrVertexPos.x = OutPositionVertexBuffer[4 * VertIdx];
		CurrVertexPos.y = OutPositionVertexBuffer[4 * VertIdx + 1];
		CurrVertexPos.z = OutPositionVertexBuffer[4 * VertIdx + 2];

		float CurrVertexInvMass = OutPositionVertexBuffer[4 * VertIdx + 3];

		// グリッドなので右方向の隣頂点と下方向の隣頂点との間のみ考慮するようにしていれば重複なくコンストレイントを処理できる

		if (ColumnIndex < NumColumn)
		{
			uint RightVertIdx = VertIdx + 1;
			float RightVertexInvMass = OutPositionVertexBuffer[4 * RightVertIdx + 3];
			if (CurrVertexInvMass > SMALL_NUMBER || RightVertexInvMass > SMALL_NUMBER)
			{
				float3 RightVertexPos;
				RightVertexPos.x = OutPositionVertexBuffer[4 * RightVertIdx];
				RightVertexPos.y = OutPositionVertexBuffer[4 * RightVertIdx + 1];
				RightVertexPos.z = OutPositionVertexBuffer[4 * RightVertIdx + 2];

				float RightEdgeLength = max(length(RightVertexPos - CurrVertexPos), SMALL_NUMBER); // to avoid 0 division
				float Diff = RightEdgeLength - GridWidth;

				float3 RightEdgeAxis = (RightVertexPos - CurrVertexPos) / RightEdgeLength;

				CurrVertexPos += CurrVertexInvMass / (CurrVertexInvMass + RightVertexInvMass) * Diff * RightEdgeAxis * Stiffness;
				RightVertexPos -= RightVertexInvMass / (CurrVertexInvMass + RightVertexInvMass) * Diff * RightEdgeAxis * Stiffness;

				OutPositionVertexBuffer[4 * RightVertIdx] = RightVertexPos.x;
				OutPositionVertexBuffer[4 * RightVertIdx + 1] = RightVertexPos.y;
				OutPositionVertexBuffer[4 * RightVertIdx + 2] = RightVertexPos.z;
			}
		}

		if (RowIndex < NumRow)
		{
			uint LowerVertIdx = VertIdx + NumColumn + 1;
			float LowerVertexInvMass = OutPositionVertexBuffer[4 * LowerVertIdx + 3];
			if (CurrVertexInvMass > SMALL_NUMBER || LowerVertexInvMass > SMALL_NUMBER)
			{
				float3 LowerVertexPos;
				LowerVertexPos.x = OutPositionVertexBuffer[4 * LowerVertIdx];
				LowerVertexPos.y = OutPositionVertexBuffer[4 * LowerVertIdx + 1];
				LowerVertexPos.z = OutPositionVertexBuffer[4 * LowerVertIdx + 2];

				float LowerEdgeLength = max(length(LowerVertexPos - CurrVertexPos), SMALL_NUMBER); // to avoid 0 division
				float Diff = LowerEdgeLength - GridHeight;

				float3 LowerEdgeAxis = (LowerVertexPos - CurrVertexPos) / LowerEdgeLength;

				CurrVertexPos += CurrVertexInvMass / (CurrVertexInvMass + LowerVertexInvMass) * Diff * LowerEdgeAxis * Stiffness;
				LowerVertexPos -= LowerVertexInvMass / (CurrVertexInvMass + LowerVertexInvMass) * Diff * LowerEdgeAxis * Stiffness;

				OutPositionVertexBuffer[4 * LowerVertIdx] = LowerVertexPos.x;
				OutPositionVertexBuffer[4 * LowerVertIdx + 1] = LowerVertexPos.y;
				OutPositionVertexBuffer[4 * LowerVertIdx + 2] = LowerVertexPos.z;
			}
		}

		OutPositionVertexBuffer[4 * VertIdx] = CurrVertexPos.x;
		OutPositionVertexBuffer[4 * VertIdx + 1] = CurrVertexPos.y;
		OutPositionVertexBuffer[4 * VertIdx + 2] = CurrVertexPos.z;
	}
}

[numthreads(1, 1, 1)]
void SolveCollision(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	float SquareSphereRadius = SphereRadius * SphereRadius;

	for (uint VertIdx = 0; VertIdx < NumVertex; VertIdx++)
	{
		float3 CurrVertexPos;
		CurrVertexPos.x = OutPositionVertexBuffer[4 * VertIdx];
		CurrVertexPos.y = OutPositionVertexBuffer[4 * VertIdx + 1];
		CurrVertexPos.z = OutPositionVertexBuffer[4 * VertIdx + 2];

		// めりこんでいれば半径方向に押し出す
		if (dot(CurrVertexPos - SphereCenter, CurrVertexPos - SphereCenter) < SquareSphereRadius)
		{
			CurrVertexPos = SphereCenter + normalize(CurrVertexPos - SphereCenter) * SphereRadius;
		}

		OutPositionVertexBuffer[4 * VertIdx] = CurrVertexPos.x;
		OutPositionVertexBuffer[4 * VertIdx + 1] = CurrVertexPos.y;
		OutPositionVertexBuffer[4 * VertIdx + 2] = CurrVertexPos.z;
	}
}
