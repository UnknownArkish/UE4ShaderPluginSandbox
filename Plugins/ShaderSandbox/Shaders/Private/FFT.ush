#include "/Engine/Public/Platform.ush"

#ifndef TWO_PI
	#define TWO_PI (2.0f * 3.1415926535897932f) // Common.ushからPIの値をとってきた
#endif

#define Complex float2

// 今回は用途が512x512の画像に固定されているのでFFTに用いる定数値を固定
// 現状ではシェーダ内のロジックが512と8を前提に書かれているので、この値は変えても動作しないのに注意
#define ARRAY_LENGTH 512
#define RADIX 8

#define NUMTHREADSX (ARRAY_LENGTH / RADIX)

// ローカルバッファ内にNaNがあったら0にする
void ScrubNANs(inout Complex Local[2][RADIX])
{
	UNROLL
	for (uint r = 0; r < RADIX; ++r)
	{	
		Local[0][r] = -min(-Local[0][r], Complex(0,0)); 
		Local[1][r] = -min(-Local[1][r], Complex(0,0)); 
	}
}

Complex ComplexMult(in Complex A, in Complex B)
{
	return Complex(A.x * B.x - A.y * B.y, A.x * B.y + B.x * A.y);
}

// 複素数配列2要素のFFT
void Radix2FFT(in bool bIsForward, inout Complex V0, inout Complex V1)
{
	V0 = V0 + V1;
	V1 = V0 - V1 - V1; // V0 - V1
}

// 複素数配列4要素のFFT
void Radix4FFT(in bool bIsForward, inout Complex V0, inout Complex V1, inout Complex V2, inout Complex V3)
{
	// 遇要素の2要素FFTと奇要素の2要素FFT
	Radix2FFT(bIsForward, V0, V2); 
	Radix2FFT(bIsForward, V1, V3); 

	// バタフライ演算
	Complex Tmp;
	Complex TmpV1 = V1;

	if (bIsForward)
	{
		// Complex(0, 1) * V3
		Tmp = Complex(-V3.y, V3.x);
	}
	else
	{
		// Complex(0, -1) * V3
		Tmp = Complex(V3.y, -V3.x);
	}

	V0 = V0 + TmpV1;
	V1 = V2 + Tmp;
	V3 = V2 - Tmp;
	V2 = V0 - TmpV1 - TmpV1; // V0 - TmpV1
}

// 複素数配列8要素のFFT
void Radix8FFT(in bool bIsForward, inout Complex V0, inout Complex V1, inout Complex V2, inout Complex V3, inout Complex V4, inout Complex V5, inout Complex V6, inout Complex V7)
{
	// 遇要素の4要素FFTと奇要素の4要素FFT
	Radix4FFT(bIsForward, V0, V2, V4, V6);
	Radix4FFT(bIsForward, V1, V3, V5, V7);

	// バタフライ演算
	float InvSqrtTwo = float(1.f) / sqrt(2.f);
	Complex Twiddle;
	if (bIsForward)
	{
		 Twiddle = Complex(InvSqrtTwo, InvSqrtTwo);
	}
	else
	{
		 Twiddle = Complex(InvSqrtTwo, -InvSqrtTwo);
	}

	Complex Result[8];
	Complex Tmp = ComplexMult(Twiddle, V3);

	Result[0] = V0 + V1;
	Result[4] = V0 - V1;

	Result[1] = V2 + Tmp;
	Result[5] = V2 - Tmp;

	if (bIsForward)
	{
		// V4 + i V5
		Result[2] = Complex(V4.x - V5.y, V4.y + V5.x);
		// V4 - i V5
		Result[6] = Complex(V4.x + V5.y, V4.y - V5.x);
	}
	else
	{
		// V4 - i V5
		Result[2] = Complex(V4.x + V5.y, V4.y - V5.x);
		// V4 + i V5
		Result[6] = Complex(V4.x - V5.y, V4.y + V5.x);
	}

	Twiddle.x = -Twiddle.x;
	Tmp = ComplexMult(Twiddle, V7);

	Result[3] = V6 + Tmp;
	Result[7] = V6 - Tmp;

	V0 = Result[0];
	V1 = Result[1];
	V2 = Result[2];
	V3 = Result[3];
	V4 = Result[4];
	V5 = Result[5];
	V6 = Result[6];
	V7 = Result[7];
}

// 複素数配列8要素のFFT
void RadixFFT(in bool bIsForward, inout Complex v[RADIX])
{
	Radix8FFT(bIsForward, v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);
}

groupshared float SharedRealBuffer[2 * ARRAY_LENGTH];
#define NUM_BANKS 32

//
// グループ内スレッド共有メモリとスレッドのローカルなバッファとのデータ交換のための関数群
//

void CopyLocalXToGroupShared(in Complex Local[RADIX], in uint Head, in uint Stride, in uint BankSkip)
{
	UNROLL
	for (uint i = Head, r = 0; r < RADIX; ++r, i += Stride)
	{
		uint j = i + (i / NUM_BANKS) * BankSkip;
		SharedRealBuffer[j] = Local[r].x;
	}
}

void CopyLocalYToGroupShared(in Complex Local[RADIX], in uint Head, in uint Stride, in uint BankSkip)
{
	UNROLL
	for (uint i = Head, r = 0; r < RADIX; ++r, i += Stride)
	{
		uint j = i + (i / NUM_BANKS) * BankSkip;
		SharedRealBuffer[j] = Local[r].y;
	}
}

void CopyGroupSharedToLocalX(inout Complex Local[RADIX], in uint Head, in uint Stride, in uint BankSkip)
{
	UNROLL
	for (uint i = Head, r = 0; r < RADIX; ++r, i += Stride)
	{
		uint j = i + (i / NUM_BANKS) * BankSkip;
		Local[r].x = SharedRealBuffer[j];
	}
}

void CopyGroupSharedToLocalY(inout Complex Local[RADIX], in uint Head, in uint Stride, in uint BankSkip)
{
	UNROLL
	for (uint i = Head, r = 0; r < RADIX; ++r, i += Stride)
	{
		uint j = i + (i / NUM_BANKS) * BankSkip;
		Local[r].y = SharedRealBuffer[j];
	}
}

void CopyLocalXToGroupShared(in Complex Local[RADIX], in uint Head, in uint Stride)
{
	CopyLocalXToGroupShared(Local, Head, Stride, 0);
}

void CopyLocalYToGroupShared(in Complex Local[RADIX], in uint Head, in uint Stride)
{
	CopyLocalYToGroupShared(Local, Head, Stride, 0);
}

// グループ内スレッド間でのデータ交換。
// 各スレッドでローカルメモリのバッファをHead1、Stride1で共有メモリに配置し、また、各スレッドでHead2、Stride2で取り出してローカルメモリに格納する。
void TransposeData(inout Complex Local[RADIX], uint Head1, uint Stride1, uint Head2, uint Stride2)
{
	uint BankSkip = (Stride1 < NUM_BANKS) ? Stride1 : 0;

	CopyLocalXToGroupShared(Local, Head1, Stride1, BankSkip);
	GroupMemoryBarrierWithGroupSync();
	CopyGroupSharedToLocalX(Local, Head2, Stride2, BankSkip);
	GroupMemoryBarrierWithGroupSync();
	CopyLocalYToGroupShared(Local, Head1, Stride1, BankSkip);
	GroupMemoryBarrierWithGroupSync();
	CopyGroupSharedToLocalY(Local, Head2, Stride2, BankSkip);
}

// 8要素FFTのバタフライ演算
void Butterfly(in const bool bIsForward, inout Complex Local[RADIX], uint ThreadIdx, uint Length)
{
	float angle = TWO_PI * (ThreadIdx % Length) / float(Length * RADIX);
	if (!bIsForward)
	{
		angle *= -1;
	}

	Complex TwiddleInc;
	sincos(angle, TwiddleInc.y, TwiddleInc.x);
	Complex Twiddle = TwiddleInc;
	for (uint r = 1; r < RADIX; r++)
	{
		Local[r] = ComplexMult(Twiddle, Local[r]);
		Twiddle = ComplexMult(Twiddle, TwiddleInc);
	}
}

// 次に共有メモリに配置するHead位置を計算する関数。
// Utility: As a function of j, 
// returns Ns contiguous values, then skips R*Ns values, then the next Ns values, etc
// (e.g. R = 3, Ns = 2: 0, 1, 6, 7, 12, 13..)
// (e.g. R = 2, Ns = 4: 0, 1, 2, 3, 8, 9, 10, 11,..)
uint Expand(in uint j, in uint Ns, in uint R) {
	return (j / Ns) * Ns * R + (j % Ns);
}

// Stockham FFT。CSのグループ内の各スレッドで実行される。共有メモリを使ってスレッド同士でデータを交換し合う。
void GroupSharedFFT(in const bool bIsForward, inout Complex Local[RADIX], in const uint ArrayLength, in const uint ThreadIdx)
{
	uint NumThreads = ArrayLength / RADIX;

	RadixFFT(bIsForward, Local);

	uint IdxSrc = ThreadIdx;
	uint IdxDist = ThreadIdx * RADIX;
	TransposeData(Local, IdxDist, 1, IdxSrc, NumThreads);		

	uint Stride = RADIX;

	for (; Stride < NumThreads; Stride *= RADIX)
	{
		Butterfly(bIsForward, Local, ThreadIdx, Stride);

		RadixFFT(bIsForward, Local);

		GroupMemoryBarrierWithGroupSync();

		IdxDist = Expand(ThreadIdx, Stride, RADIX);
		TransposeData(Local, IdxDist, Stride, IdxSrc, NumThreads);
	}

	Butterfly(bIsForward, Local, ThreadIdx, Stride);

	RadixFFT(bIsForward, Local);

	GroupMemoryBarrierWithGroupSync();
}

void Scale(inout Complex LocalComplexBuffer[2][RADIX], in float ScaleValue)
{
	for (uint r = 0; r < RADIX; ++r)
	{
		LocalComplexBuffer[0][r] *= ScaleValue;
	}
	for (uint r = 0; r < RADIX; ++r)
	{
		LocalComplexBuffer[1][r] *= ScaleValue;
	}
}

// CSの1スレッドから実行するFFT。共有メモリを使ってグループ内のスレッド同士でデータを交換し合う。
void GroupSharedFFT(in bool bIsForward, inout Complex LocalComplexBuffer[2][RADIX], in uint ArrayLength, in uint ThreadIdx)
{
	if (!bIsForward)
	{
		// ここでは1/Nのスケールは逆変換側につける方法を採用する
		Scale(LocalComplexBuffer, 1.0f / float(ArrayLength));
	}

	GroupSharedFFT(bIsForward, LocalComplexBuffer[0], ArrayLength, ThreadIdx);
	GroupSharedFFT(bIsForward, LocalComplexBuffer[1], ArrayLength, ThreadIdx);
}

