#include "/Engine/Public/Platform.ush"
#include "FFT.ush"

uint Forward;
Texture2D<float4> SrcTexture;
RWTexture2D<float4> DstTexture;
uint2 SrcRectMin;
uint2 SrcRectMax;
uint4 DstRect;

// The Two-For-One trick:  FFT two real signals (f,g) of length N 
// are transformed simultaneously by treating them as a single complex signal z.
// z_n = f_n + I * g_n.
// 
// Giving the complex amplitudes (i.e. the transform)  Z_k = F_k + I * G_k.
//
// The transforms of the real signals can be recovered as
//
//  F_k = (1/2) (Z_k + ComplexConjugate(Z_{N-k}))
//  G_k = (-i/2)(Z_k - ComplexConjugate(Z_{N-k}))
//
// Furthermore, the transform of any real signal x_n has the symmetry
//  X_k = ComplexConjugate(X_{N-k})   


// Separate the FFT of two real signals that were processed togehter
// using the two-for-one trick.
//
// On input the data in LocalComplexBuffer across the threads in this group
// holds the transform  of the complex signal z = f + I * g of lenght N.
//
// On return the transform of f and g have been separated and stored
// in the LocalComplexBuffer in a form consistent with the packing the x-signal transform forward, 
// followed by the y-signal transform in reverse.
// 
// {F_o, G_o}, {F_1}, {F_2},..,{F_{N/2-1}}, {F_N/2, G_N/2}, {G_{N/2 +1}},  {G_{N/2 +2}}, .., {G_{N-2}},    {G_{N-1}} 
//     0       , 1    , 2    ,..., N/2-1,       N/2,           N/2 +1,      N/2 +2,  ..,  N/2- (2-N/2),   N/2 - (1-N/2)
// here {} := Complex
void PackLocalBuffer(inout Complex LocalComplexBuffer[RADIX], in uint Head, in uint Stride, in uint N)
{
	const uint Non2 = N / 2;
	
	// On input, Each thread has, in LocalComplexBuffer, the frequencies
	// K = Head + j * Stride;  where j = 0, .., RADIX-1.. Head = ThreadIDx, Stride = NumberOfThreads

	// Write the complex FFT into group shared memory.
	
	CopyLocalXToGroupShared(LocalComplexBuffer, Head, Stride);
	GroupMemoryBarrierWithGroupSync();

	// Construct the transform for the two real signals in the LocalComplexBuffer
	UNROLL
	for (uint i = 0, K = Head; i < RADIX; ++i, K += Stride)
	{
		//
		// K = N/2 - abs(SrcIdx - N/2)

		// DstK = SrcIdx % Non2;
		// N - k
		
		FLATTEN
		uint NmK = (K > 0) ? (N - K) : 0;

		// Z_k = LocalComplexBuffer[i]
		// If k < N/2  : Store  F_k = 1/2 (Z_k + Z*_{N-k})
		// If k > N/2  : Compute I*G_k = 1/2 (Z_k - Z*_{N-k})
		
		// Tmp =  {+,-}ComplexConjugate( Z_{N-k})
		float Tmp = SharedRealBuffer[NmK];
		Tmp *= (K > Non2) ? -1 : 1;
		LocalComplexBuffer[i].x += Tmp;
	}

	if (Head == 0)
	{
		LocalComplexBuffer[0].x = 2.0f * SharedRealBuffer[0];
	}

	GroupMemoryBarrierWithGroupSync();
	CopyLocalYToGroupShared(LocalComplexBuffer, Head, Stride);
	GroupMemoryBarrierWithGroupSync();

	UNROLL
	for (uint i = 0, K = Head; i < RADIX; ++i, K += Stride)
	{
		//
		// K = N/2 - abs(SrcIdx - N/2)

		// DstK = SrcIdx % Non2;
		// N - k
		
		FLATTEN
		uint NmK = (K > 0) ? (N - K) : 0;

		// Z_k = LocalComplexBuffer[i]
		// If k < N/2  : Store  F_k = 1/2 (Z_k + Z*_{N-k})
		// If k > N/2  : Compute I*G_k = 1/2 (Z_k - Z*_{N-k})
		
		// Tmp =  {+,-}ComplexConjugate( Z_{N-k})
		float Tmp = -SharedRealBuffer[NmK];
		
		Tmp *= (K < Non2) ? 1 : -1;

		LocalComplexBuffer[i].y += Tmp;
	}

	if (Head == 0)
	{
		LocalComplexBuffer[0].y = 2.0f * SharedRealBuffer[0];
	}

	UNROLL
	for (uint i = 0; i < RADIX; ++i)
	{
		LocalComplexBuffer[i] *= 0.5; 
	}

	UNROLL
	for (uint i = 0, K = Head; i < RADIX; ++i, K += Stride)
	{
		// If k > N/2 get G_k from I*G_k:  G_k = -I * (I G_k)
		if (K > Non2)
		{
			LocalComplexBuffer[i] = ComplexMult(Complex(0, -1), LocalComplexBuffer[i]);
		}
	}
}

// Inverse of PackLocalBuffer()
// Combine the FFT of two real signals (f,g) into a single complex signal
// for use in inverting a "two-for-one" FFT .
//
//
// On return the transform of f and g have been separated and stored
// in the LocalComplexBuffer in a form consistent with the packing the x-signal transform forward, 
// followed by the y-signal transform in reverse.
// 
// {F_o, G_o}, {F_1}, {F_2},..,{F_{N/2-1}}, {F_N/2, G_N/2}, {G_{N/2 +1}},  {G_{N/2 +2}}, .., { G_{N-2}},    {G_{N-1}} 
//     0       , 1    , 2    ,..., N/2-1,       N/2,           N/2 +1,      N/2 +2,      ..,  N/2- (2-N/2),  N/2 - (1-N/2)
// here {} := Complex
//
// On return the data in LocalComplexBuffer across the threads in this group
// hold the transform  of the complex signal z = f + ig of lenght N.
//
void UnpackLocalBuffer(inout Complex LocalComplexBuffer[RADIX], in uint Head, in uint Stride, in uint N)
{
	uint Non2 = N / 2;

	// Write the two FFTs into shared memory.
	float TmpX[RADIX];
	for (uint i = 0; i < RADIX; ++i)
	{
		TmpX[i] = LocalComplexBuffer[i].x;
	}

	CopyLocalYToGroupShared(LocalComplexBuffer, Head, Stride);

	GroupMemoryBarrierWithGroupSync();

	// Compose the transform of a single f+ig signal from the two real signals in the LocalComplexBuffer
	UNROLL
	for (uint i = 0, K = Head; i < RADIX; ++i, K += Stride)
	{
		// N - k 
		FLATTEN uint NmK = (K > 0) ? (N - K) : 0;

		// If k < N/2  : LocalComplexBuffer[i] = F_k,  
		//               Shared[N-K] =  G[N-K] = Conjugate(G[k]) =  (G[k]_r, -G[k]_i) = Complex(G_r, -G_i)
		//                          want   I G[k] =  float(-G[k]_i, G[k]_r)
		//                 Tmp = I * G_k   
		// If k > N/2  : LocalComplexBuffer[i] = G_k 
		//               Shared[N-K] = F[N-k] = Conjugate(F[k]) = Complex(F[k]_r, -F[k]_i)
		//                           want -I F[k] = Complex(F[k]_i, -F[k]_r)
		//                 Tmp = -I * F   
		//  ComplexConjugate( Z_{N-k})

		// Tmp = (K < Non2) ? I *  G_k : -I * F
		float Tmp = SharedRealBuffer[NmK];

		Tmp *= (K > Non2) ? -1 : 1;

		LocalComplexBuffer[i].x += Tmp;
	}

	float2 FirstElement = float2(0, SharedRealBuffer[0]);
	float2 MiddleElement = float2(0, SharedRealBuffer[Non2]);

	GroupMemoryBarrierWithGroupSync();

	// Copy TmpX to GroupShared
	UNROLL
	for (uint r = 0, i = Head; r < RADIX; ++r, i += Stride)
	{
		SharedRealBuffer[i] = TmpX[r];
	}

	GroupMemoryBarrierWithGroupSync();
	FirstElement.x = SharedRealBuffer[0];
	MiddleElement.x = SharedRealBuffer[Non2];

	UNROLL
	for (uint i = 0, K = Head; i < RADIX; ++i, K += Stride)
	{
		// N - k 
		FLATTEN uint NmK = (K > 0) ? (N - K) : 0;

		// If k < N/2  : LocalComplexBuffer[i] = F_k,  
		//               Shared[N-K] =  G[N-K] = Conjugate(G[k]) =  (G[k]_r, -G[k]_i) = Complex(G_r, -G_i)
		//                          want   I G[k] =  float(-G[k]_i, G[k]_r)
		//                 Tmp = I * G_k   
		// If k > N/2  : LocalComplexBuffer[i] = G_k 
		//               Shared[N-K] = F[N-k] = Conjugate(F[k]) = Complex(F[k]_r, -F[k]_i)
		//                           want -I F[k] = Complex(F[k]_i, -F[k]_r)
		//                 Tmp = -I * F   
		//  ComplexConjugate( Z_{N-k})

		// Tmp = (K < Non2) ? I *  G_k : -I * F
		float Tmp = SharedRealBuffer[ NmK ]; 
		Tmp *= (K > Non2) ? -1 : 1;
		
		LocalComplexBuffer[i].y += Tmp;
	}

	UNROLL
	for (uint i = 0, K = Head; i < RADIX; ++i, K += Stride)
	{
		// if k > N/2 we have G - I *  F.  Multiply by I to get F + I * G
		if (K > Non2)
		{
			LocalComplexBuffer[i] = ComplexMult(Complex(0, 1), LocalComplexBuffer[i]);
		}

		if (K == Non2)
		{
			// F_N/2 + I * G_N/2
			LocalComplexBuffer[i] = MiddleElement;
		}
	}

	if (Head == 0)
	{
		LocalComplexBuffer[0] = FirstElement;
	}
}

// The inverse of PackLocalBufferAndCopyToDstTexture()
// Reads into local registers, data written in the HalfCompressedFrequency layout back into the form consistent with the transform of a single complex signal.
//const bool bIsHorizontal = true;
void CopySrcTextureToLocalBufferAndUnpack(inout Complex LocalComplexBuffer[2][RADIX], in uint ScanIdx, in uint Loc, in uint Stride, in uint N)
{
	const bool bIsFirstElement = (Loc == 0);
	const uint Non2 =  N / 2;

	// last two values
	float4 NValue = SrcTexture[uint2(N, ScanIdx)];
	float4 NppValue = SrcTexture[uint2(N + 1, ScanIdx)];

	uint2 Pixel = uint2(Loc, ScanIdx);
	UNROLL
	for (uint i = 0; i < RADIX; ++i, Pixel.x += Stride)
	{
		float4 SrcValue = SrcTexture[Pixel];
		LocalComplexBuffer[0][i] = SrcValue.xy;
		LocalComplexBuffer[1][i] = SrcValue.zw;

		// 以下の2ブロックの処理でパディング分の2ピクセルを埋めている

		if (Pixel.x == Non2)
		{
			// local buffer will be pure real with F_N/2,  need to add I * G_N/2 (G_N/2 is real ie float2(G_r, 0))
			LocalComplexBuffer[0][i] += NppValue.yx;
			LocalComplexBuffer[1][i] += NppValue.wz;
		}
	}

	if (bIsFirstElement)
	{
		LocalComplexBuffer[0][0] += NValue.yx;
		LocalComplexBuffer[1][0] += NValue.wz;
	}

	// Combine the transforms of the two real signals (F,G) as Z = F + I G
	UnpackLocalBuffer(LocalComplexBuffer[ 0 ], Loc, Stride, N);
	GroupMemoryBarrierWithGroupSync();
	UnpackLocalBuffer(LocalComplexBuffer[ 1 ], Loc, Stride, N);
	
	// Done with the group shared memory that was used in the merge
	GroupMemoryBarrierWithGroupSync();
}

void PackLocalBufferAndCopyToDstTexture(inout Complex LocalComplexBuffer[2][RADIX], uint ScanIdx, uint Loc, uint Stride, uint N)
{
	GroupMemoryBarrierWithGroupSync();

	// Decompose the transforms.  Note '0' and 'N/2' offsets will still be mixed, and have to be explicitly dealt with below. 
	PackLocalBuffer(LocalComplexBuffer[0], Loc, Stride, N);
	GroupMemoryBarrierWithGroupSync();
	PackLocalBuffer(LocalComplexBuffer[1], Loc, Stride, N);

	const bool bIsFirstElement = (Loc == 0);
	const uint Non2 =  N / 2;

	// 行処理にしか使わない前提
	uint2 Pixel = uint2(Loc, ScanIdx);
	float4 DstValue;
	UNROLL
	for (uint r = 0; r < RADIX; ++r, Pixel.x += Stride)
	{
		DstValue.xy = LocalComplexBuffer[0][r];
		DstValue.zw = LocalComplexBuffer[1][r];
		DstTexture[Pixel] = DstValue;

		// 以下の2ブロックの処理でパディング分の2ピクセルを埋めている

		// The N/2 element holds F_N/2 + I G_N/2
		// Write F_N/2 into this column, and G_N/2 into the the last column 
		if (Pixel.x == Non2)
		{
			DstTexture[Pixel] = float4(DstValue.x, 0.0f, DstValue.z, 0.0f);
			DstTexture[uint2(N + 1, Pixel.y)] = float4(DstValue.y, 0.0f, DstValue.w, 0.0f);
		}
	}

	// First element holds F_o + iG_o.  
	// Write Go into the second to last column. (this is the same as G_N)
	if (bIsFirstElement)
	{
		DstValue.xy = LocalComplexBuffer[0][0];
		DstValue.zw = LocalComplexBuffer[1][0];

		DstTexture[uint2(0, Pixel.y)] = float4(DstValue.x, 0.0f, DstValue.z, 0.0f); // F_o 
		DstTexture[uint2(N, Pixel.y)] = float4(DstValue.y, 0.0f, DstValue.w, 0.0f); // G_o 
	}
}

void CopySrcTextureToLocalBuffer(inout Complex LocalComplexBuffer[2][RADIX], in uint ScanIdx, uint Loc, uint Stride, uint4 Window)
{
	for (uint i = 0; i < RADIX; i++)
	{
		LocalComplexBuffer[0][i] = Complex(0.0f, 0.0f);
		LocalComplexBuffer[1][i] = Complex(0.0f, 0.0f);
	}

	// 行処理でしか使わない前提
	uint2 Pixel = uint2(Loc, ScanIdx) + Window.xy;
	UNROLL
	for (uint i = 0; i < RADIX; ++i, Pixel.x += Stride)
	{
		bool IsWindow = !(Pixel.x > Window.z);
		if (IsWindow)
		{
			// RGBAの4チャンネルを2つの複素数で保持する
			float4 SrcValue = SrcTexture[Pixel];
			LocalComplexBuffer[0][i] = SrcValue.xy;
			LocalComplexBuffer[1][i] = SrcValue.zw;
		}
	}
}

//const bool bIsHorizontal = false;
void CopySrcTextureToLocalBuffer(inout Complex LocalComplexBuffer[2][RADIX], uint ScanIdx, uint Loc, uint Stride, uint2 WindowMin, uint2 WindowMax)
{
	for (uint i = 0; i < RADIX; i++)
	{
		LocalComplexBuffer[0][i] = Complex(0.0f, 0.0f);
		LocalComplexBuffer[1][i] = Complex(0.0f, 0.0f);
	}

	// 列処理でしか使わない前提
	uint2 Pixel = uint2(ScanIdx, Loc) + uint2(0, WindowMin.y);
	UNROLL
	for (uint i = 0; i < RADIX; ++i, Pixel.y += Stride)
	{
		bool IsWindow = !(Pixel.y > WindowMax.y);
		if (IsWindow)
		{
			// RGBAの4チャンネルを2つの複素数で保持する
			float4 SrcValue = SrcTexture[Pixel];
			LocalComplexBuffer[0][i] = SrcValue.xy;
			LocalComplexBuffer[1][i] = SrcValue.zw;
		}
	}
}

void CopyLocalBufferToDstTexture(in Complex LocalComplexBuffer[2][RADIX], bool bIsHorizontal, in uint ScanIdx, uint Loc, uint Stride, uint4 ROIRect)
{
	if(bIsHorizontal)
	{
		uint2 Pixel = uint2(Loc + ROIRect.x, ScanIdx + ROIRect.y);

		UNROLL
		for (uint r = 0; r < RADIX && Pixel.x < ROIRect.z; ++r, Pixel.x += Stride)
		{
			float4 DstValue;
			DstValue.xy = LocalComplexBuffer[0][r];
			DstValue.zw = LocalComplexBuffer[1][r];

			DstTexture[Pixel] = DstValue;
		}
	}
	else
	{
		uint2 Pixel = uint2(ScanIdx + ROIRect.x, Loc + ROIRect.y);

		UNROLL
		for (uint r = 0; r < RADIX && Pixel.y < ROIRect.w; ++r, Pixel.y += Stride)
		{
			float4 DstValue;
			DstValue.xy = LocalComplexBuffer[0][r];
			DstValue.zw = LocalComplexBuffer[1][r];

			DstTexture[Pixel] = DstValue;
		}
	}
}

// テクスチャの横方向のラインをFFT/IFFTする。
// 実数配列限定で、FFT後のデータを半分の容量にパッキングする。
// RGBAの4実数がある場合、フーリエ変換では4複素数が出力されるのでデータの容量が倍になる。
// しかし、実数配列をフーリエ変換した場合、KとN-Kの周波数のフーリエ変換結果が複素共役になるという対称性がある。
// それを用いて、保存データを半分で済ませることで、入力テクスチャと出力テクスチャを同じ容量で済ませる。
[numthreads(NUMTHREADSX, 1, 1)]
void HalfPackFFTTexture2DHorizontal(uint GroupID : SV_GroupID, uint GroupThreadID : SV_GroupThreadID)
{
	const bool bIsForward = (Forward > 0);
	// 今回は用途として行処理固定
	const bool bIsHorizontal = true;

	// 各スレッドがソーステクスチャのある行の各ピクセルデータに対応
	const uint ThreadIdx = GroupThreadID;
	// 各グループがソーステクスチャのある行に対応
	const uint LineIdx  = GroupID;

	// メモリアクセスパターン変数
	uint Head = ThreadIdx;
	const uint Stride = ARRAY_LENGTH / RADIX;

	// ワークバッファとして使う配列。各スレッドのローカル変数
	// RGとBAを2つの複素数に格納する
	Complex LocalComplexBuffer[2][RADIX];

	if (bIsForward)
	{
		uint4 SrcRect;
		SrcRect.xy = SrcRectMin.xy;
		SrcRect.zw = SrcRectMax.xy;
		CopySrcTextureToLocalBuffer(LocalComplexBuffer, LineIdx, Head, Stride, SrcRect);
	}
	else
	{
		CopySrcTextureToLocalBufferAndUnpack(LocalComplexBuffer, LineIdx, Head, Stride, ARRAY_LENGTH);
	}

	// FFTあるいはIFFT。複数スレッドで共有メモリを使って協調して行う
	GroupSharedStockhamFFT(bIsForward, LocalComplexBuffer, ARRAY_LENGTH, ThreadIdx);

	if (bIsForward)
	{
		// Write a frequency space buffer with two-for-one data layout
		// GroupMemoryBarrierWithGroupSync();
		PackLocalBufferAndCopyToDstTexture(LocalComplexBuffer, LineIdx, Head, Stride, ARRAY_LENGTH);
	}
	else
	{
		// Write image space data.
		// GroupMemoryBarrierWithGroupSync();

		// This is specialized for images, where floating point errors may have
		// resulted in (very very small) negative color values.
		ScrubNANs(LocalComplexBuffer);

		CopyLocalBufferToDstTexture(LocalComplexBuffer, bIsHorizontal, LineIdx, Head, Stride, DstRect);
	}
}

// テクスチャのRGBAに2つの複素数が格納されているものとし、縦方向のラインにFFT/IFFTを行う。
[numthreads(NUMTHREADSX, 1, 1)]
void FFTTexture2DVertical(uint GroupID : SV_GroupID, uint GroupThreadID : SV_GroupThreadID)
{
	// RGBAが2複素数に対応していると解釈して行うFFT/IFFT

	const bool bIsForward = (Forward > 0);
	// 今回は用途として列処理固定
	const bool bIsHorizontal = false;

	// 各スレッドがソーステクスチャのある列の各ピクセルデータに対応
	const uint ThreadIdx = GroupThreadID;
	// 各グループがソーステクスチャのある列に対応
	const uint LineIdx = GroupID;

	// ワークバッファとして使う配列。各スレッドのローカル変数
	// RGとBAに2つの複素数が格納されている
	Complex LocalComplexBuffer[2][RADIX];

	// メモリアクセスパターン変数
	uint Head = ThreadIdx;
	const uint Stride = ARRAY_LENGTH / RADIX;

	// ソーステクスチャの画像のピクセルを間隔をあけながら8個ローカルメモリに格納する
	CopySrcTextureToLocalBuffer(LocalComplexBuffer, LineIdx, Head, Stride, SrcRectMin, SrcRectMax);

	// FFTあるいはIFFT。複数スレッドで共有メモリを使って協調して行う
	GroupSharedStockhamFFT(bIsForward, LocalComplexBuffer, ARRAY_LENGTH, ThreadIdx);

	// FFT結果を出力先テクスチャに格納する
	CopyLocalBufferToDstTexture(LocalComplexBuffer, bIsHorizontal, LineIdx, Head, Stride, DstRect); // DstRect.MinがFIntPoint(0,0)である前提がある
}

